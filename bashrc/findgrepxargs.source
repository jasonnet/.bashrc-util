#!/bin/sh

# See ffindgrepxargs_help for more info.

function ffindgrepxargs_help() {
  cat << EOF
# Search filenames recursively from current directory, filtering
# out certain names, and acting on a list of those file names
#
# Ex.
# To list in details, date-sorted files with filenames like Hyundai and hyundai
#     ffindgrepxargs                      hyundai
#   or more explicitly
#     ffindgrepxargs  -y                  hyundai      ls -ltr
# To list them without details one per line unsorted
#     ffindgrepxargs                      hyundai      ls
#   or
#     ffindgrepxargs                      hyundai      -L1
#   or more explicitly
#     ffindgrepxargs                      hyundai      -L1  echo
#    or
#     ffindgrepxargs                      hyundai      -L1  ls
# To list filenames grouped into one line
#     ffindgrepxargs                      hyundai      echo
# To list only case specific, change that to
#     ffindgrepxargs    --no-ignore-case  Hyundai
# You can specify wild cards and other grep expressions but might need to quote
#     ffindgrepxargs                      "happy.*[.]htm.*"
# The xargs commands can be varied:
#     ffindgrepxargs    --no-ignore-case "[.]DELETEME"        rm
#
# Motivation:
#    - The need to do this is frequent, but it's often made difficult by 
#      filenames that contain spaces.
#    - The syntax needed to do this when file names contain spaces is 
#      difficult to remember.
#
# Source:  $BASH_SOURCE
#
EOF
}

function findgrepxargs() {
  echo "use ffindgrepxargs command instead.  It does not take the first argument and instead starts from the current directory"
}

function ffindgrepxargs() {
    #local dir=${1:---help}
    #shift
    local dir=.   # current directory

    if [ "$dir" = "--help" ] ; then
	  ffindgrepxargs_help
      return 2
    fi

    # grepflags (optional)
    #  usually you can skip this
    #  if specified, it has to start with a -
    #  if multiple flags, then quote it and include spaces as needed (and still start with a dash)
    # note: the grep case-insensitive default is disabled here, so you are likely to want to specify -i or -y to reenable it
    local grepflags=$1   
    shift

    # regex
    #  can contain spaces, but will need to then be quoted.
    local regex

    if [[ "$grepflags" == "-"* ]] ; then 
      # that really was grepflags, so now...
      regex=$1
      shift  # consume the regex parameter and leave the rest
    else
      # that was not really grepflags, so treat it as regex and leave the remaining parameters...
      regex="$grepflags"
      #unset grepflags   # commented out because let's make -y the default
      grepflags="-y"
      # TODO: this means the only way to specify case sensitive is
      # TODO: instead of unsetting ^^^, we could specify -y
    fi
    # the remaining parameters will be treated as command parameters.  They probably will not be quoted when used.
	# ...but because I almsot always pass the same command, I'll set a default value.
	local xargs_invokes=
	#echo "arg2 is '${2}'  $#"
	if [ "$#" = "0" ]; then
	  # The user specified no command 
	  xargs_invokes=("ls" "-ltr")
      #echo "aa $xargs_invokes"
	else   
	  xargs_invokes=("$@")
      #echo "bb $xargs_invokes"
	fi

    # Note: we do not quote $grepflags because 
    #         if unset, then the quoted parameter is passed to grep as an empty string rather than a skipped parameter.   If we find that we want to specify multiple par
    #         and if multiple flags were set, we don't want them treated as a single flag parameter
    #       we do specify --no-ignore-case because IMHO that should be the default because it's easy to turn it off and cumbersome for the user to set it
	find "$dir" -type f  -print0 | grep -z --no-filename --no-ignore-case $grepflags --regexp="$regex" -  | xargs --null  --no-run-if-empty "${xargs_invokes[@]}" 
}
